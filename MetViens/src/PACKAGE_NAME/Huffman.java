package PACKAGE_NAME;

import java.util.PriorityQueue;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.Charset;
import java.util.Comparator;

public class Huffman {

    class HuffmanNode {
		int data;
        char character;
        HuffmanNode left;
        HuffmanNode right;
        
        public HuffmanNode(int i, char c) {
			// TODO Auto-generated constructor stub
        	this.data = i;
        	this.character = c;
        	left = null;
        	right = null;
		}
    }

	private static final char EMPTY_CHARACTER = 0;
    
    public static void main(String[] args) 
    { 
    	Huffman mHuf = new Huffman();
    	HuffmanNode root = null;
    	/* Lai notestētu vai strādā koka ielasīšana
    	try {
			root = mHuf.treeGen("XXXXX",false);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    	
    	System.out.println(root.data + "a");
    	printCode(root, "");*/
    	
    }
    // TODO : izņemt šo metodi, bet pēc viņas principa izveidot 
    // HashMap, lai vienkāršāk Encode failu
    public static void printCode(HuffmanNode root, String s) 
    { 
  
        // base case; if the left and right are null 
        // then its a leaf node and we print 
        // the code s generated by traversing the tree. 
        if (root.left 
                == null
            && root.right 
                   == null
            && ((int)root.character != 0)) { 
  
            // c is the character in the node 
            System.out.println(root.character + ":" + s); 
  
            return; 
        } 
  
        // if we go to left then add "0" to the code. 
        // if we go to the right add"1" to the code. 
  
        // recursive calls for left and 
        // right sub-tree of the generated tree. 
        printCode(root.left, s + "0"); 
        printCode(root.right, s + "1"); 
    }
    // Aizpilda koka sarakstu no saspiesta faila
    public void binFill(PriorityQueue<HuffmanNode> tree, Reader fr) throws Exception
    {
    	int i, iBinTotal, nodeF = 0, pos = 0;
    	String sBinTotal = "";
    	
    	// Pārlasām pāri vārdnīcas ievaddatiem
    	// Nolasām vārdnīcas kopējo baitu izmēru
		while ((i = fr.read()) != -1 && (char) i != ' ')
		{
			sBinTotal += (char) i;
			pos++;
		} 
		iBinTotal = Integer.parseInt(sBinTotal);
		
		while (pos < iBinTotal)
		{
			sBinTotal = "";
			i = fr.read(); // nolasām simbolu
			pos++; // palielinām apstrādāto baitu
			// Ja varējām nolasīt simbolu, tad pieglabājam
			final char nodeC = (i != -1) ? (char) i : 0;
			
			if (nodeC == 0) throw new Exception("Kļūda nolasot failu : Simbols netika atrasts!");
			
			fr.read(); //nolasām atstarpi pirms biežuma
			while ((i = fr.read()) != -1 && (char) i != ' ')
			{
				sBinTotal += (char) i;
				pos++;
			} 
			nodeF = Integer.parseInt(sBinTotal);
			
			if (tree.stream().filter(node -> node.character == nodeC).count() > 0)
			{
				throw new Exception("Kļūda nolasot failu : Atkārtojas simboli vārdnīca!");
			}
			else
			{
				tree.add(new HuffmanNode(nodeF,nodeC));
			}
		}
    }
    // Aizpilda koka sarakstu no plain-text faila
    public void plainFill(PriorityQueue<HuffmanNode> tree, Reader fr) throws IOException
    {	
    	int i;
		while ((i = fr.read()) != -1)
		{
			final char ch = (char) i;
			// Ja kādai virsotnei piemīt šis simbols, tad mēs palielinām biežumu par 1, citādi
			// pievienojam to rindai.
			//TODO : replace 'c' with iterative symbol from file read
			if (tree.stream().filter(node -> node.character == ch).count() > 0 ) 
			{
				tree.parallelStream()
					.filter(node -> node.character == ch)
					.forEach(node -> node.data++);
			}
			else
			{
				tree.add(new HuffmanNode(1, ch));
			}
		}
    }
    
    
    /**  
     * <h1>Metode, kas nolasa failu, iegūst simbolu biežumus un izveido koku.</h1>
     * <br> 
     * @param fPath : Saņem ceļu uz failu
     * @param isBinary : Nosaka vai koku veido no saspiesta vai plain-text faila
     * @return HuffmanNode - saknes virsotne
     * @throws IOException Ja nevar nolasīt no faila simbolu
     * */
    public HuffmanNode treeGen(String fPath, Boolean isBinary) throws IOException 
    {
    	// Izveido prioritātes rindu, kur elementi 
    	// tiek kartoti pēc compare metodes(simbola biežuma)
    	// Padod sākotnējos izmērus(pēc noklusējuma ir 11) un metodi, kas salīdzina elementus
    	PriorityQueue<HuffmanNode> tree = new PriorityQueue<HuffmanNode>(11, 
    		new  Comparator<HuffmanNode>()
    		{
				public int compare(HuffmanNode arg0, HuffmanNode arg1) {
					// TODO Auto-generated method stub
					return arg0.data - arg1.data;
				}
    		}
    	);
    	
    	// Atveram failu pirmajai lasīšanai
    	InputStream is = new FileInputStream(fPath);
    	Reader fr = new InputStreamReader(is, Charset.forName("UTF-8"));
    	try
    	{
    	if (isBinary == true) binFill(tree, fr); else plainFill(tree, fr);
    	} catch(Exception e)
    	{
    		e.getStackTrace();
    	}
    	
    	// Aizveram faila lasīšanu    	
    	fr.close();

    	// Pašlaik ir sakārtota rinda ar atsevišķām virsotnēm
    	// Nepieciešams virsotnes apvienot kokā!
    	
    	// Izveidojam saknes virsotni, no kuras sāks lasīt šifrētās vērtības
    	HuffmanNode root = null;
    	
    	// Izveidojam koka struktūru
    	while (tree.size()>1)
    	{
    		HuffmanNode one = tree.peek();
    		tree.poll();
    		
    		HuffmanNode two = tree.peek();
    		tree.poll();
    		
    		HuffmanNode combo = new HuffmanNode(0, EMPTY_CHARACTER);
    		combo.data = one.data + two.data;
    		combo.left = one;
    		combo.right = two;
    		
    		root = combo;
    		tree.add(combo);
    	}
    	
    	// atgriežam saknes virsotni.
		return root;
    }

}