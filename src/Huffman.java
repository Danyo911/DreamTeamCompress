import java.util.PriorityQueue;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.UnsupportedEncodingException;
import java.nio.charset.Charset;
import java.util.Comparator;
import java.util.HashMap;

public class Huffman {

    class HuffmanNode {
		int data;
        char character;
        HuffmanNode left;
        HuffmanNode right;
        
        public HuffmanNode(int i, char c) {
			// TODO Auto-generated constructor stub
        	this.data = i;
        	this.character = c;
        	left = null;
        	right = null;
		}
    }

	private static final char EMPTY_CHARACTER = 0;
	private static HashMap<Character, String> hashmap = new HashMap<Character, String>();
	
    public static void main(String[] args) 
    { 
    	
    	Huffman mHuf = new Huffman();
    	HuffmanNode root = null;
    	PriorityQueue<HuffmanNode> que = null;
    	/* Lai notestētu vai strādā koka ielasīšana */
    	try {
    		que = mHuf.nodeListGen("char_count.txt",false);
			root = mHuf.treeGen(que);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    	
    	System.out.println(root.data + "a");
    	printCode(root, "");
    	
    	PriorityQueue<HuffmanNode> que2 = null;
    	try {
			que2 = mHuf.nodeListGen("char_count.txt", false);
			mHuf.fileEncoder(hashmap, "char_count.txt", que2);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    	
    }
    // TODO : izņemt šo metodi, bet pēc viņas principa izveidot 
    // HashMap, lai vienkāršāk Encode failu
    public static void printCode(HuffmanNode root, String s) 
    { 
  
        // base case; if the left and right are null 
        // then its a leaf node and we print 
        // the code s generated by traversing the tree. 
        if (root.left 
                == null
            && root.right 
                   == null
            && ((int)root.character != 0)) { 
  
            // c is the character in the node 
            System.out.println(root.character + ":" + s);
            //Write to hashmap
            hashmap.put(root.character,s);  
            return; 
        } 
  
        // if we go to left then add "0" to the code. 
        // if we go to the right add"1" to the code. 
  
        // recursive calls for left and 
        // right sub-tree of the generated tree. 
        printCode(root.left, s + "0"); 
        printCode(root.right, s + "1"); 
    }
    // Aizpilda koka sarakstu no saspiesta faila
    public void binFill(PriorityQueue<HuffmanNode> tree, Reader fr) throws Exception
    {
    	int i, iBinTotal, nodeF = 0, pos = 0;
    	String sBinTotal = "";
    	
    	// Pārlasām pāri vārdnīcas ievaddatiem
    	// Nolasām vārdnīcas kopējo baitu izmēru
		while ((i = fr.read()) != -1 && (char) i != ' ')
		{
			sBinTotal += (char) i;
			pos++;
		} 
		iBinTotal = Integer.parseInt(sBinTotal);
		
		while (pos < iBinTotal)
		{
			sBinTotal = "";
			i = fr.read(); // nolasām simbolu
			pos++; // palielinām apstrādāto baitu
			// Ja varējām nolasīt simbolu, tad pieglabājam
			final char nodeC = (i != -1) ? (char) i : 0;
			
			if (nodeC == 0) throw new Exception("Kļūda nolasot failu : Simbols netika atrasts!");
			
			fr.read(); //nolasām atstarpi pirms biežuma
			while ((i = fr.read()) != -1 && (char) i != ' ')
			{
				sBinTotal += (char) i;
				pos++;
			} 
			nodeF = Integer.parseInt(sBinTotal);
			
			if (tree.stream().filter(node -> node.character == nodeC).count() > 0)
			{
				throw new Exception("Kļūda nolasot failu : Atkārtojas simboli vārdnīca!");
			}
			else
			{
				tree.add(new HuffmanNode(nodeF,nodeC));
			}
		}
    }
    // Aizpilda koka sarakstu no plain-text faila
    public void plainFill(PriorityQueue<HuffmanNode> tree, Reader fr) throws IOException
    {	
    	int i;
		while ((i = fr.read()) != -1)
		{
			final char ch = (char) i;
			// Ja kādai virsotnei piemīt šis simbols, tad mēs palielinām biežumu par 1, citādi
			// pievienojam to rindai.
			//TODO : replace 'c' with iterative symbol from file read
			if (tree.stream().filter(node -> node.character == ch).count() > 0 ) 
			{
				tree.parallelStream()
					.filter(node -> node.character == ch)
					.forEach(node -> node.data++);
			}
			else
			{
				tree.add(new HuffmanNode(1, ch));
			}
		}
    }
 
    
    public void fileEncoder(HashMap<Character, String> enc_map, String filePath, PriorityQueue<HuffmanNode> que) {
    	// Jaunā faila nosaukums
    	String out_filename = "encoded_file.txt";
    	// Savāc bibliotēku iekš sevis
    	String frequencies = " ";
    	while(que.size() > 0) {
    		HuffmanNode node = que.peek();
    		que.poll();
    		frequencies += node.character + " " + node.data + " ";
    	}
    	byte[] bytes = null;
		try {
			bytes = frequencies.getBytes("UTF-8");
		} catch (UnsupportedEncodingException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		// Iegūst baitus pirms satura (vajadzības gadījumā var pieskaitīt skaitli, lai būtu buffer)
    	int bytes_to_content = bytes.length + 2;
    	// Izveido jaunu failu
    	File output_file = new File(out_filename);
    	// Atver failu lasīšanai
    	InputStream is = null;
		try {
			is = new FileInputStream(filePath);
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
    	Reader fr = new InputStreamReader(is, Charset.forName("UTF-8"));
    	int r;
    	// Faila rakstītājs
    	String bin_string = "";
    	String char_string = "";
    	char character;
    	try {
    		FileWriter fwr = new FileWriter(out_filename);		
        	fwr.write(bytes_to_content + " " + frequencies);
        	/* Lasa input failu pa vienai rakstzīmei. 
        	Kad tā sakrīt ar atslēgu no HashMap, tiek ierakstīts kods mainīgajā. */
        	while ((r = fr.read()) != -1) {
        		char c = (char) r;
        		for (Character i : enc_map.keySet()) {
        			if (c == i)
        				bin_string += enc_map.get(i);
        		}
        	}
        	// Pēc tam iterē pāri mainīgajam, skalda daļās, katru daļu uz char
        	for (int i = 0; i < bin_string.length() - 8; i += 8) {
        		character = (char)Integer.parseInt(bin_string.substring(i, i + 8), 2);
        		char_string += character;
        	}
        	fwr.write(char_string);
        	fwr.close();
    	} catch (IOException e) {
    		System.out.println("Notikusi kļūda");
    	}
    	System.out.println("Saspiešana pabeigta");
    }
    
    
    
    /**  
     * <h1>Metode, kas nolasa failu, iegūst simbolu biežumus un izveido koku.</h1>
     * <br> 
     * @param fPath : Saņem ceļu uz failu
     * @param isBinary : Nosaka vai koku veido no saspiesta vai plain-text faila
     * @return HuffmanNode - saknes virsotne
     * @throws IOException Ja nevar nolasīt no faila simbolu
     * */
public PriorityQueue<HuffmanNode> nodeListGen(String fPath, Boolean isBinary) throws IOException{
	// Izveido prioritātes rindu, kur elementi 
	// tiek kartoti pēc compare metodes(simbola biežuma)
	// Padod sākotnējos izmērus(pēc noklusējuma ir 11) un metodi, kas salīdzina elementus
	PriorityQueue<HuffmanNode> tree = new PriorityQueue<HuffmanNode>(11, 
		new  Comparator<HuffmanNode>()
		{
			public int compare(HuffmanNode arg0, HuffmanNode arg1) {
				// TODO Auto-generated method stub
				return arg0.data - arg1.data;
			}
		}
	);
	
	// Atveram failu pirmajai lasīšanai
	InputStream is = new FileInputStream(fPath);
	Reader fr = new InputStreamReader(is, Charset.forName("UTF-8"));
	try
	{
	if (isBinary == true) binFill(tree, fr); else plainFill(tree, fr);
	} catch(Exception e)
	{
		e.getStackTrace();
	}
	
	// Aizveram faila lasīšanu    	
	fr.close();
	return tree;
	}
    public HuffmanNode treeGen(PriorityQueue<HuffmanNode> tree) throws IOException 
    {  	
    	// Pašlaik ir sakārtota rinda ar atsevišķām virsotnēm
    	// Nepieciešams virsotnes apvienot kokā!
    	
    	// Izveidojam saknes virsotni, no kuras sāks lasīt šifrētās vērtības
    	HuffmanNode root = null;
    	
    	// Izveidojam koka struktūru
    	while (tree.size()>1)
    	{
    		HuffmanNode one = tree.peek();
    		tree.poll();
    		
    		HuffmanNode two = tree.peek();
    		tree.poll();
    		
    		HuffmanNode combo = new HuffmanNode(0, EMPTY_CHARACTER);
    		combo.data = one.data + two.data;
    		combo.left = one;
    		combo.right = two;
    		
    		root = combo;
    		tree.add(combo);
    	}
    	
    	// atgriežam saknes virsotni.
		return root;
    }
}